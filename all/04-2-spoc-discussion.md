```
可能出现以下三种情况 
【情况1】：B(t)属于S(t),且B(t)属于S’(t),则经过这一步，需要将S(t)与S’(t)中的B(t)页都置于栈顶部，因为S1的栈大小大于S(t),所以对于B(t)元素，还是满足B(t)在S(t)中的位置，小于B(t)在S’(t)中的位置。对于原有在S(t)与S’(t)中的元素，在B(t)元素前的元素位置不变，在B(t)后的元素位置整体前移，大小关系保持不变。所以这种情况下依旧满足条件。 【情况2】：B(t)不属于S(t),且B(t)属于S’(t)。B(t)不属于S(t),就在栈顶压入元素，B(t)位置为n；在S‘(t)中找到B(t)，将B(t)元素移至栈顶，依旧满足S(t)中B(t)位置小于等于S‘(t)中位置。对于原有在S(t)中的元素，整体前移了一位，S’(t)中元素B(t)前的不变，B(t)后的整体前移1位，所以整体大小关系依旧满足。 【情况3】：B(t)不属于S(t),且B(t)不属于S‘(t),则都在栈尾部加入B(t)，S(t)中位置为n，S’(t)中位置为n+k。同时对于被弹出栈的元素，如果弹出元素相同，则依旧满足。如果弹出元素不同，因为S(t)中的对应元素位置小于等于S‘(t)的，所以S’(t)中弹出的元素必然已经不属于S(t)了。所以弹出后依旧满足S(t)属于S‘(t).即在这种情况下依旧满足假设。 由于假设的存在，S(t)属于S’(t),即不会出现B(t)属于S(t),B(t)不属于S‘(t)的情况。 综上所述，由数学归纳法得，对任意时刻t，S(t)属于S’(t),且任意S(t)中元素a，对应到S’(t)中元素a1，满足a的位置小于等于a1的栈位置。即对任意时刻，对S’(t)的缺页数量不会大于S(t)。即物理页数量增加，缺页率不会上升。即LRU算法不会出现belady现象。
```
